<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Obsidian-Honcho: Specification</title>
<style>
  :root {
    --bg:             #0b0e14;
    --bg-surface:     #11151c;
    --bg-elevated:    #181d27;
    --bg-code:        #0d1018;
    --fg:             #c9d1d9;
    --fg-bright:      #e6edf3;
    --fg-muted:       #6e7681;
    --fg-subtle:      #484f58;
    --accent:         #7eb8f6;
    --accent-dim:     #3d6ea5;
    --accent-glow:    rgba(126, 184, 246, 0.08);
    --green:          #7ee6a8;
    --green-dim:      #2ea04f;
    --orange:         #e6a855;
    --red:            #f47067;
    --purple:         #bc8cff;
    --cyan:           #56d4dd;
    --border:         #21262d;
    --border-subtle:  #161b22;
    --radius:         6px;
    --font-sans:      'New York', ui-serif, 'Iowan Old Style', 'Apple Garamond', Baskerville, 'Times New Roman', 'Noto Emoji', serif;
    --font-mono:      'Departure Mono', 'Noto Emoji', monospace;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  html { scroll-behavior: smooth; scroll-padding-top: 2rem; }

  body {
    font-family: var(--font-sans);
    background: var(--bg);
    color: var(--fg);
    line-height: 1.7;
    font-size: 15px;
    -webkit-font-smoothing: antialiased;
  }

  /* -- Layout ----------------------------------------- */
  .container {
    max-width: 860px;
    margin: 0 auto;
    padding: 3rem 2rem 6rem;
  }

  /* -- Hero ------------------------------------------- */
  .hero {
    text-align: center;
    padding: 4rem 0 3rem;
    border-bottom: 1px solid var(--border);
    margin-bottom: 3rem;
  }
  .hero h1 {
    font-family: var(--font-mono);
    font-size: 2.4rem;
    font-weight: 700;
    color: var(--fg-bright);
    letter-spacing: -0.03em;
    margin-bottom: 0.5rem;
  }
  .hero h1 span { color: var(--accent); }
  .hero .subtitle {
    font-family: var(--font-sans);
    color: var(--fg-muted);
    font-size: 0.92rem;
    max-width: 540px;
    margin: 0 auto;
    line-height: 1.6;
  }
  .hero .meta {
    margin-top: 1.5rem;
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    flex-wrap: wrap;
  }
  .hero .meta span {
    font-size: 0.8rem;
    color: var(--fg-subtle);
    font-family: var(--font-mono);
  }
  .hero .meta span a {
    color: var(--accent-dim);
    text-decoration: none;
  }
  .hero .meta span a:hover { color: var(--accent); }

  /* -- TOC -------------------------------------------- */
  .toc {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 1.5rem 2rem;
    margin-bottom: 3rem;
  }
  .toc h2 {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--fg-muted);
    margin-bottom: 1rem;
  }
  .toc ol {
    list-style: none;
    counter-reset: toc;
    columns: 2;
    column-gap: 2rem;
  }
  .toc li {
    counter-increment: toc;
    break-inside: avoid;
    margin-bottom: 0.35rem;
  }
  .toc li::before {
    content: counter(toc, decimal-leading-zero) " ";
    color: var(--fg-subtle);
    font-family: var(--font-mono);
    font-size: 0.75rem;
    margin-right: 0.25rem;
  }
  .toc a {
    font-family: var(--font-mono);
    color: var(--fg);
    text-decoration: none;
    font-size: 0.82rem;
    transition: color 0.15s;
  }
  .toc a:hover { color: var(--accent); }

  /* -- Sections --------------------------------------- */
  section { margin-bottom: 4rem; }
  section + section { padding-top: 1rem; }

  h2 {
    font-family: var(--font-mono);
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--fg-bright);
    letter-spacing: -0.01em;
    margin-bottom: 1.25rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border);
  }
  h3 {
    font-family: var(--font-mono);
    font-size: 1rem;
    font-weight: 600;
    color: var(--fg-bright);
    margin-top: 2rem;
    margin-bottom: 0.75rem;
  }
  h4 {
    font-family: var(--font-mono);
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--accent);
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
  }

  p { margin-bottom: 1rem; font-size: 0.95rem; line-height: 1.75; }
  strong { color: var(--fg-bright); font-weight: 600; }

  a { color: var(--accent); text-decoration: none; }
  a:hover { text-decoration: underline; }

  /* -- Lists ------------------------------------------ */
  ul, ol { margin-bottom: 1rem; padding-left: 1.5rem; font-size: 0.93rem; line-height: 1.7; }
  li { margin-bottom: 0.35rem; }
  li::marker { color: var(--fg-subtle); }

  /* -- Tables ----------------------------------------- */
  .table-wrap { overflow-x: auto; margin-bottom: 1.5rem; }
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.88rem;
  }
  th, td {
    text-align: left;
    padding: 0.6rem 1rem;
    border-bottom: 1px solid var(--border-subtle);
  }
  th {
    font-family: var(--font-mono);
    font-size: 0.72rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--fg-muted);
    background: var(--bg-surface);
    border-bottom-color: var(--border);
    white-space: nowrap;
  }
  td { font-family: var(--font-sans); font-size: 0.88rem; color: var(--fg); }
  tr:hover td { background: var(--accent-glow); }
  td code {
    background: var(--bg-elevated);
    padding: 0.15em 0.4em;
    border-radius: 3px;
    font-family: var(--font-mono);
    font-size: 0.82em;
    color: var(--cyan);
  }

  /* -- Code Blocks ------------------------------------ */
  pre {
    background: var(--bg-code);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 1.25rem 1.5rem;
    overflow-x: auto;
    margin-bottom: 1.5rem;
    font-family: var(--font-mono);
    font-size: 0.82rem;
    line-height: 1.65;
    color: var(--fg);
  }
  pre code { background: none; padding: 0; color: inherit; font-size: inherit; }
  code {
    font-family: var(--font-mono);
    font-size: 0.85em;
  }

  /* inline code */
  p code, li code {
    background: var(--bg-elevated);
    padding: 0.15em 0.4em;
    border-radius: 3px;
    color: var(--cyan);
    font-size: 0.85em;
  }

  /* -- Syntax colors (manual highlighting) ------------ */
  .kw { color: var(--purple); }
  .str { color: var(--green); }
  .cm { color: var(--fg-subtle); font-style: italic; }
  .num { color: var(--orange); }
  .key { color: var(--accent); }

  /* -- Mermaid ---------------------------------------- */
  .mermaid {
    margin: 1.5rem 0 2rem;
    text-align: center;
  }
  .mermaid svg { max-width: 100%; height: auto; }

  /* -- Callouts --------------------------------------- */
  .callout {
    font-family: var(--font-sans);
    background: var(--bg-surface);
    border-left: 3px solid var(--accent-dim);
    border-radius: 0 var(--radius) var(--radius) 0;
    padding: 1rem 1.25rem;
    margin-bottom: 1.5rem;
    font-size: 0.88rem;
    color: var(--fg-muted);
    line-height: 1.6;
  }
  .callout strong { font-family: var(--font-mono); color: var(--fg-bright); }
  .callout.success { border-left-color: var(--green-dim); }
  .callout.warn { border-left-color: var(--orange); }

  /* -- Badges ----------------------------------------- */
  .badge {
    display: inline-block;
    font-family: var(--font-mono);
    font-size: 0.65rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 0.2em 0.6em;
    border-radius: 3px;
    vertical-align: middle;
    margin-left: 0.4rem;
  }
  .badge-done { background: var(--green-dim); color: #fff; }
  .badge-wip { background: var(--orange); color: #0b0e14; }
  .badge-todo { background: var(--fg-subtle); color: var(--fg); }

  /* -- Checklist -------------------------------------- */
  .checklist { list-style: none; padding-left: 0; }
  .checklist li { padding-left: 1.5rem; position: relative; margin-bottom: 0.5rem; }
  .checklist li::before {
    position: absolute;
    left: 0;
    font-family: var(--font-mono);
    font-size: 0.85rem;
  }
  .checklist li.done { color: var(--fg-muted); }
  .checklist li.done::before { content: "\2713"; color: var(--green); }
  .checklist li.todo::before { content: "\25CB"; color: var(--fg-subtle); }
  .checklist li.wip::before { content: "\25D4"; color: var(--orange); }

  /* -- Comparison grid -------------------------------- */
  .compare {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-bottom: 2rem;
  }
  .compare-card {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 1.25rem;
  }
  .compare-card h4 { margin-top: 0; font-size: 0.82rem; }
  .compare-card.after { border-color: var(--accent-dim); }
  .compare-card ul { font-family: var(--font-mono); padding-left: 1.25rem; font-size: 0.8rem; }

  /* -- Divider ---------------------------------------- */
  hr {
    border: none;
    border-top: 1px solid var(--border);
    margin: 3rem 0;
  }

  /* -- Responsive ------------------------------------- */
  @media (max-width: 640px) {
    .container { padding: 2rem 1rem 4rem; }
    .hero h1 { font-size: 1.6rem; }
    .toc ol { columns: 1; }
    .compare { grid-template-columns: 1fr; }
    table { font-size: 0.8rem; }
    th, td { padding: 0.4rem 0.6rem; }
  }

  /* -- Scroll indicator ------------------------------- */
  .progress-bar {
    position: fixed;
    top: 0;
    left: 0;
    height: 2px;
    background: var(--accent);
    z-index: 999;
    transition: width 0.1s linear;
  }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Emoji&display=swap" rel="stylesheet">
<style>
  @font-face {
    font-family: 'Departure Mono';
    src: url('https://cdn.jsdelivr.net/gh/rektdeckard/departure-mono@latest/fonts/DepartureMono-Regular.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
    font-display: swap;
  }
</style>
</head>
<body>

<div class="progress-bar" id="progress"></div>

<div class="container">

<!-- =============== HERO =============== -->
<header class="hero">
  <h1>obsidian<span>-honcho</span></h1>
  <p class="subtitle">Persistent identity for your knowledge base. The vault is the brain; Honcho is the memory.</p>
  <div class="meta">
    <span><a href="https://github.com/plastic-labs/obsidian-honcho">plastic-labs/obsidian-honcho</a></span>
    <span>TypeScript / Bun</span>
    <span>2026-02-24</span>
  </div>
</header>

<!-- =============== TOC =============== -->
<nav class="toc">
  <h2>Contents</h2>
  <ol>
    <li><a href="#concept">Concept</a></li>
    <li><a href="#architecture">Architecture</a></li>
    <li><a href="#standalone">Standalone Plugin</a></li>
    <li><a href="#agentic">Agentic Integration</a></li>
    <li><a href="#tools">MCP Tool Reference</a></li>
    <li><a href="#data-flow">Data Flow</a></li>
    <li><a href="#setup">Setup Guide</a></li>
    <li><a href="#status">Current Status</a></li>
  </ol>
</nav>

<!-- =============== CONCEPT =============== -->
<section id="concept">
  <h2>Concept</h2>

  <p>Obsidian is where you think. Honcho is what remembers. The premise of this project is that a personal knowledge base -- notes, journals, ideas, references -- is the highest-fidelity signal of who someone is and how they think. Not chat logs. Not browsing history. The structured artifacts a person deliberately creates and maintains.</p>

  <p>Honcho reasons over conversations. It derives conclusions, builds representations, and tracks how understanding evolves over time. The Obsidian plugin translates vault notes into a form Honcho can reason over: each note becomes a session with structured metadata and full content. Honcho observes and derives meaning. The conclusions it generates are persistent, searchable, and usable by any downstream system.</p>

  <p>There are two ways to use this system, and they compose. Used alone, the plugin gives Obsidian a persistent memory layer -- your vault accumulates identity over time. Combined with the MCP server, external agents gain vault access and workspace-specific intelligence, making your knowledge base an autonomous resource that agents can consult, extend, and reason over.</p>

  <div class="callout">
    <strong>Key distinction</strong> &mdash; There are two Honcho MCPs. The <strong>generic Honcho MCP</strong> (<code>mcp.honcho.dev</code>) handles workspace-agnostic operations: semantic search, chat, conclusions. The <strong>Obsidian-Honcho MCP</strong> handles vault access and obsidian-workspace-specific Honcho operations. They are designed to run alongside each other.
  </div>
</section>

<!-- =============== ARCHITECTURE =============== -->
<section id="architecture">
  <h2>Architecture</h2>

  <div class="mermaid">
%%{init: {'theme': 'dark', 'themeVariables': { 'primaryColor': '#1f3150', 'primaryTextColor': '#c9d1d9', 'primaryBorderColor': '#3d6ea5', 'lineColor': '#3d6ea5', 'secondaryColor': '#162030', 'tertiaryColor': '#11151c', 'edgeLabelBackground': '#0b0e14' }}}%%
flowchart TD
    VAULT["Obsidian Vault<br/>(markdown files)"]
    PLUGIN["Obsidian Plugin<br/>(ingestion bridge)"]
    HONCHO["Honcho API<br/>(identity + memory)"]
    OMCP["Obsidian-Honcho MCP<br/>(vault + workspace tools)"]
    HMCP["Generic Honcho MCP<br/>(mcp.honcho.dev)"]
    AGENT["Agent<br/>(Claude, etc.)"]

    VAULT <-->|"read/write"| PLUGIN
    PLUGIN -->|"sessions + messages"| HONCHO
    HONCHO -->|"conclusions +<br/>representations"| PLUGIN
    OMCP <-->|"CLI / REST / filesystem"| VAULT
    OMCP <-->|"classify, reflect, status"| HONCHO
    HMCP <-->|"search, chat, conclude"| HONCHO
    AGENT -->|"tool calls"| OMCP
    AGENT -->|"tool calls"| HMCP

    style VAULT fill:#162030,stroke:#3d6ea5,color:#c9d1d9
    style PLUGIN fill:#1f3150,stroke:#3d6ea5,color:#c9d1d9
    style HONCHO fill:#1f3150,stroke:#7ee6a8,color:#c9d1d9
    style OMCP fill:#162030,stroke:#bc8cff,color:#c9d1d9
    style HMCP fill:#162030,stroke:#bc8cff,color:#c9d1d9
    style AGENT fill:#11151c,stroke:#e6a855,color:#c9d1d9
  </div>

  <h3>Components</h3>

  <div class="table-wrap">
    <table>
      <thead><tr><th>Component</th><th>Role</th><th>Runs Where</th></tr></thead>
      <tbody>
        <tr><td><strong>Obsidian Vault</strong></td><td>The knowledge base. Markdown files with frontmatter, wikilinks, tags, folder hierarchy.</td><td>Local filesystem</td></tr>
        <tr><td><strong>Obsidian Plugin</strong></td><td>Ingestion bridge. Reads vault notes, creates Honcho sessions, tracks sync status. Chat sidebar for direct conversation with Honcho.</td><td>Inside Obsidian</td></tr>
        <tr><td><strong>Honcho API</strong></td><td>Persistent identity engine. Observes messages, derives conclusions, builds representations, processes dreams.</td><td>Cloud (<code>api.honcho.dev</code>)</td></tr>
        <tr><td><strong>Obsidian-Honcho MCP</strong></td><td>9 tools: 6 vault access + 3 workspace-specific Honcho operations. External agents use this to interact with your vault and its Honcho workspace.</td><td>Local process (Bun)</td></tr>
        <tr><td><strong>Generic Honcho MCP</strong></td><td>Workspace-agnostic Honcho operations: semantic search, conversational chat, direct conclusion creation.</td><td>Cloud (<code>mcp.honcho.dev</code>)</td></tr>
      </tbody>
    </table>
  </div>

  <hr style="border-style: dotted; border-color: var(--border); margin: 1.5rem 0;">

  <div class="table-wrap">
    <table>
      <thead><tr><th>Component</th><th>Role</th><th>Runs Where</th></tr></thead>
      <tbody>
        <tr><td><strong>Obsidian CLI</strong> <span class="badge badge-todo">OPTIONAL</span></td><td>Agent entry point. You are the peer. Your notes are your &ldquo;messages&rdquo; &mdash; not conversational messages, but vault content uploaded as messages in the Honcho architecture. Each note becomes a session with paired messages (document context + body) linked by a shared <code>turn_id</code>.</td><td>Local process (Bun)</td></tr>
      </tbody>
    </table>
  </div>

  <h3>Single-Peer Model</h3>

  <p>The system collapses Honcho's observer/observed peer architecture to a single peer. You are the peer. Your notes are your messages. Honcho observes you and derives conclusions about your thinking, knowledge structure, and patterns. The peer configuration is <code>{ observe_me: true }</code> -- Honcho watches what you write and builds understanding from it.</p>
</section>

<!-- =============== STANDALONE =============== -->
<section id="standalone">
  <h2>Setup 1: Standalone Plugin</h2>

  <p><strong>What you need:</strong> Obsidian + the plugin + a Honcho API key.</p>

  <p>The plugin alone turns your vault into a persistent identity source. No agents, no MCP servers, no CLI tools. You write notes in Obsidian. The plugin sends them to Honcho. Honcho learns.</p>

  <h3>What the Plugin Does</h3>
  <ul>
    <li><strong>Ingestion.</strong> Each note becomes a Honcho session with exactly 2 messages: a document context message (metadata, graph position, tags, links, folder, properties) and the full note body. The pair is linked by a shared <code>turn_id</code> &mdash; an 8-character hex hash, like a short git commit hash &mdash; so the context and content are always queryable as a unit. Deterministic session IDs (<code>obsidian-file-{slug}</code>) so re-ingesting updates rather than duplicates.</li>
    <li><strong>Sync tracking.</strong> FNV-1a content hashing detects changes. Frontmatter fields (<code>synced</code>, <code>session</code>, <code>hash</code>) track what has been sent. Unchanged notes are skipped automatically.</li>
    <li><strong>Auto-sync.</strong> Optionally re-ingests notes on save with configurable debounce (10s) and per-file cooldown (default 5 minutes). Tag and folder filters let you scope which notes auto-sync.</li>
    <li><strong>Chat.</strong> Sidebar chat grounded in the current note's Honcho session. Conversation with Honcho about what it has observed.</li>
    <li><strong>Batch operations.</strong> Ingest entire folders, all notes matching a tag, or a note plus its linked neighborhood (configurable depth).</li>
  </ul>

  <h3>What Honcho Provides</h3>
  <ul>
    <li><strong>Conclusions.</strong> Honcho's observation pipeline derives atomic insights from your notes -- patterns in your thinking, connections between ideas, knowledge gaps, recurring themes. These are persistent and searchable.</li>
    <li><strong>Representations.</strong> A synthesized model of you, focused through any search query. Ask Honcho to represent you through the lens of a specific topic and it constructs a view from relevant conclusions.</li>
    <li><strong>Dreams.</strong> Scheduled processing that synthesizes across sessions, finding deeper patterns that span multiple notes. Triggered automatically after batch ingestion.</li>
    <li><strong>Accumulation.</strong> Every note you ingest adds signal. Over time, Honcho's model of your thinking becomes increasingly refined. The vault is the input; the identity is the output.</li>
  </ul>

  <div class="callout success">
    <strong>The value proposition</strong> &mdash; Your notes already represent your thinking. The plugin makes that representation machine-readable and persistent. Honcho turns it into something any system can reason over.
  </div>
</section>

<!-- =============== AGENTIC =============== -->
<section id="agentic">
  <h2>Setup 2: Agentic Integration</h2>

  <p>The agentic layer turns your vault from a passive knowledge store into an active resource that external agents can consult, reason over, and extend. An agent with vault access and Honcho's accumulated identity model can ground its responses in your actual documented thinking &mdash; not just the current conversation window, but the full history of what you've written, organized, and refined.</p>

  <p><strong>What you need:</strong> Everything from Setup 1, plus the Obsidian-Honcho MCP server, and optionally the generic Honcho MCP.</p>

  <p>The MCP server exposes your vault and its Honcho workspace to external agents. Claude, or any MCP-capable system, can read your notes, write new ones, search your vault, analyze its structure, and tap into the identity Honcho has built from your ingested content.</p>

  <h3>What the MCP Server Adds</h3>

  <h4>Vault Access (6 tools)</h4>
  <p>Direct read/write/search access to Obsidian's vault. These tools work independently of Honcho -- they are pure vault operations routed through whichever transport is available.</p>
  <ul>
    <li><code>vault_read</code> -- Read a note's raw content</li>
    <li><code>vault_write</code> -- Create, append, prepend, set/remove properties, move, delete, bookmark, daily note append</li>
    <li><code>vault_search</code> -- Keyword search across the vault</li>
    <li><code>vault_info</code> -- Complete note intelligence: metadata, graph position, structure, properties, tags, aliases (7 parallel queries)</li>
    <li><code>vault_list</code> -- List files, optionally by folder or extension</li>
    <li><code>vault_graph</code> -- Vault-wide structural health: orphans, dead-ends, unresolved links, tag distribution, recent files, pending tasks</li>
  </ul>

  <h4>Workspace Bridge (3 tools)</h4>
  <p>These tools operate on the <strong>obsidian workspace</strong> in Honcho -- the workspace where your ingested vault content lives. They combine vault data with Honcho's accumulated understanding.</p>
  <ul>
    <li><code>vault_classify</code> -- Ask Honcho to suggest tags, title improvements, or connections for a note based on accumulated vault knowledge. Uses <code>peerChat</code> on the note's ingestion session.</li>
    <li><code>vault_reflect</code> -- Get Honcho's perspective on a note: direct conclusions from that session, semantically related conclusions from across the vault, and a representation focused through the note's content.</li>
    <li><code>vault_status</code> -- Workspace overview: vault file counts, ingested sessions, coverage percentage, conclusion totals, processing queue state.</li>
  </ul>

  <h3>Combined with the Generic Honcho MCP</h3>
  <p>Adding <code>mcp.honcho.dev</code> alongside the Obsidian-Honcho MCP gives agents full Honcho access beyond the obsidian workspace:</p>
  <ul>
    <li><strong>Semantic search</strong> across all workspaces and conclusions</li>
    <li><strong>Conversational chat</strong> in any session context</li>
    <li><strong>Direct conclusion creation</strong> -- agents can write observations back to Honcho</li>
  </ul>

  <p>The two MCPs do not overlap. The Obsidian-Honcho MCP handles vault access and workspace-specific operations. The generic Honcho MCP handles everything else.</p>

  <h3>What This Makes Possible</h3>
  <p>An agent with both MCPs can:</p>
  <ul>
    <li>Read your notes to understand context before responding</li>
    <li>Search your vault for relevant prior work</li>
    <li>Check what Honcho has concluded about your thinking patterns</li>
    <li>Suggest organizational improvements based on accumulated knowledge</li>
    <li>Create new notes or append to existing ones</li>
    <li>Audit your vault's structural health (orphans, dead-ends, unresolved links)</li>
    <li>Ground its responses in your actual documented knowledge, not just the current conversation</li>
  </ul>

  <div class="callout">
    <strong>The plugin is the bridge, not the brain</strong> &mdash; Ingestion is the plugin's job. Intelligence is the agent's job. The plugin is deliberately minimal: it reads vault content, sends it to Honcho, and tracks what has been sent. Everything else -- classification, reflection, search, reasoning -- happens at the MCP/agent layer where it belongs.
  </div>
</section>

<!-- =============== TOOLS =============== -->
<section id="tools">
  <h2>MCP Tool Reference</h2>

  <div class="table-wrap">
    <table>
      <thead><tr><th>Tool</th><th>Type</th><th>Description</th><th>Key Parameters</th></tr></thead>
      <tbody>
        <tr><td><code>vault_read</code></td><td>Vault</td><td>Read raw note content</td><td><code>file</code> (required)</td></tr>
        <tr><td><code>vault_write</code></td><td>Vault</td><td>9 write actions: create, append, prepend, property set/remove, move, delete, bookmark, daily append</td><td><code>action</code> (required), <code>file</code>, <code>content</code>, etc.</td></tr>
        <tr><td><code>vault_search</code></td><td>Vault</td><td>Keyword search. Semantic search lives at <code>mcp.honcho.dev</code>.</td><td><code>query</code> (required), <code>limit</code></td></tr>
        <tr><td><code>vault_info</code></td><td>Vault</td><td>Complete note intelligence (7 parallel queries)</td><td><code>file</code> (required)</td></tr>
        <tr><td><code>vault_list</code></td><td>Vault</td><td>List vault files</td><td><code>folder</code>, <code>ext</code>, <code>total</code></td></tr>
        <tr><td><code>vault_graph</code></td><td>Vault</td><td>Vault structural health report (6 parallel analyses)</td><td><code>include</code> (array of analyses)</td></tr>
        <tr><td><code>vault_classify</code></td><td>Bridge</td><td>Honcho-powered tag/title/connection suggestions</td><td><code>file</code> (required), <code>scope</code></td></tr>
        <tr><td><code>vault_reflect</code></td><td>Bridge</td><td>Conclusions + representation for a note</td><td><code>file</code> (required)</td></tr>
        <tr><td><code>vault_status</code></td><td>Bridge</td><td>Workspace coverage and queue state</td><td>(none)</td></tr>
      </tbody>
    </table>
  </div>
</section>

<!-- =============== DATA FLOW =============== -->
<section id="data-flow">
  <h2>Data Flow</h2>

  <h3>Ingestion Pipeline (Plugin)</h3>
  <div class="mermaid">
%%{init: {'theme': 'dark', 'themeVariables': { 'primaryColor': '#1f3150', 'primaryTextColor': '#c9d1d9', 'primaryBorderColor': '#3d6ea5', 'lineColor': '#3d6ea5', 'secondaryColor': '#162030', 'tertiaryColor': '#11151c', 'edgeLabelBackground': '#0b0e14' }}}%%
flowchart TD
    NOTE["Vault Note"]
    HASH["Compute content hash<br/>(FNV-1a on stripped body)"]
    CHECK{"Hash changed?"}
    SKIP["Skip (unchanged)"]
    CTX["Build document context<br/>(metadata, graph position,<br/>tags, links, properties)"]
    STRIP["Strip frontmatter<br/>(raw body content)"]
    SESSION["Get/create Honcho session<br/>(obsidian-file-{slug})"]
    MSG1["Message 1:<br/>Document context"]
    MSG2["Message 2:<br/>Full body"]
    FM["Update frontmatter<br/>(synced, session, hash)"]
    DREAM["Schedule dream<br/>(batch only)"]

    NOTE --> HASH
    HASH --> CHECK
    CHECK -->|"No"| SKIP
    CHECK -->|"Yes"| CTX
    CHECK -->|"Yes"| STRIP
    CTX --> SESSION
    STRIP --> SESSION
    SESSION --> MSG1
    SESSION --> MSG2
    MSG1 --> FM
    MSG2 --> FM
    FM -.-> DREAM

    style NOTE fill:#162030,stroke:#3d6ea5,color:#c9d1d9
    style HASH fill:#11151c,stroke:#3d6ea5,color:#c9d1d9
    style CHECK fill:#162030,stroke:#e6a855,color:#c9d1d9
    style SKIP fill:#11151c,stroke:#484f58,color:#6e7681
    style CTX fill:#1f3150,stroke:#3d6ea5,color:#c9d1d9
    style STRIP fill:#1f3150,stroke:#3d6ea5,color:#c9d1d9
    style SESSION fill:#1f3150,stroke:#7ee6a8,color:#c9d1d9
    style MSG1 fill:#162030,stroke:#7ee6a8,color:#c9d1d9
    style MSG2 fill:#162030,stroke:#7ee6a8,color:#c9d1d9
    style FM fill:#11151c,stroke:#3d6ea5,color:#c9d1d9
    style DREAM fill:#11151c,stroke:#bc8cff,color:#c9d1d9
  </div>

  <h3>Transport Chain (MCP Server)</h3>
  <p>The MCP server accesses the vault through a three-tier fallback chain. Each transport provides the same command interface; the server auto-detects which is available.</p>

  <div class="table-wrap">
    <table>
      <thead><tr><th>Priority</th><th>Transport</th><th>Requires</th><th>Capabilities</th></tr></thead>
      <tbody>
        <tr><td>1</td><td><strong>CLI</strong></td><td>Obsidian 1.12+ with CLI enabled</td><td>Full: all commands including bookmark, daily append</td></tr>
        <tr><td>2</td><td><strong>REST</strong></td><td>Local REST API plugin</td><td>Full: all commands via HTTP</td></tr>
        <tr><td>3</td><td><strong>Filesystem</strong></td><td><code>OBSIDIAN_VAULT_PATH</code> env var</td><td>Most commands. No bookmark or daily append (requires Obsidian internals).</td></tr>
      </tbody>
    </table>
  </div>

  <p>The filesystem transport parses markdown directly -- frontmatter, wikilinks, tags, headings -- so the MCP server works even when Obsidian is not running. Override with <code>OBSIDIAN_TRANSPORT=cli|rest|fs</code>.</p>
</section>

<!-- =============== SETUP =============== -->
<section id="setup">
  <h2>Setup Guide</h2>

  <h3>Plugin Only (Setup 1)</h3>

  <h4>Option A: Global config (shared with Cursor / Claude Code)</h4>
  <p>If you already use <a href="https://github.com/plastic-labs/cursor-honcho">cursor-honcho</a> or <a href="https://github.com/plastic-labs/claude-honcho">claude-honcho</a>, you have a <code>~/.honcho/config.json</code>. Add an <code>obsidian</code> host block:</p>
  <pre><code>{
  <span class="key">"apiKey"</span>: <span class="str">"hch-your-key-here"</span>,
  <span class="key">"peerName"</span>: <span class="str">"your-name"</span>,
  <span class="key">"hosts"</span>: {
    <span class="key">"cursor"</span>:     { <span class="key">"workspace"</span>: <span class="str">"cursor"</span>, <span class="key">"aiPeer"</span>: <span class="str">"cursor"</span> },
    <span class="key">"claude_code"</span>: { <span class="key">"workspace"</span>: <span class="str">"claude_code"</span>, <span class="key">"aiPeer"</span>: <span class="str">"claude"</span> },
    <span class="key">"obsidian"</span>:    { <span class="key">"workspace"</span>: <span class="str">"obsidian"</span> }
  }
}</code></pre>
  <p>The plugin reads this file automatically. Your API key, peer name, and workspace are shared across all three surfaces. Obsidian's settings UI still works as a local override.</p>

  <h4>Option B: Plugin settings only</h4>
  <ol>
    <li>Install the plugin in Obsidian</li>
    <li>Enter your Honcho API key in Settings &rarr; Honcho &rarr; Connection</li>
    <li>Test connection (green dot in sidebar)</li>
    <li>Ingest notes manually (right-click &rarr; Ingest to Honcho) or enable auto-sync</li>
    <li>Open the chat sidebar to converse with Honcho about ingested content</li>
  </ol>

  <div class="callout">
    <strong>Config layering</strong> &mdash; Defaults &lt; <code>~/.honcho/config.json</code> &lt; Obsidian plugin settings. The global config provides shared values; anything set in Obsidian's settings UI takes precedence.
  </div>

  <h3>Plugin + Obsidian-Honcho MCP (Setup 2)</h3>
  <ol>
    <li>Complete Setup 1</li>
    <li>Register the MCP server with your agent platform</li>
  </ol>

  <h4>Claude Desktop configuration</h4>
  <pre><code>{
  <span class="key">"mcpServers"</span>: {
    <span class="key">"obsidian-honcho"</span>: {
      <span class="key">"command"</span>: <span class="str">"bun"</span>,
      <span class="key">"args"</span>: [<span class="str">"run"</span>, <span class="str">"/path/to/obsidian-honcho/mcp/server.ts"</span>],
      <span class="key">"env"</span>: {
        <span class="key">"HONCHO_API_KEY"</span>: <span class="str">"your-key"</span>,
        <span class="key">"HONCHO_WORKSPACE"</span>: <span class="str">"obsidian"</span>,
        <span class="key">"HONCHO_PEER"</span>: <span class="str">"your-name"</span>,
        <span class="key">"OBSIDIAN_VAULT_PATH"</span>: <span class="str">"/path/to/your/vault"</span>
      }
    }
  }
}</code></pre>

  <h4>Environment variables</h4>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Variable</th><th>Required</th><th>Default</th><th>Description</th></tr></thead>
      <tbody>
        <tr><td><code>HONCHO_API_KEY</code></td><td>Yes</td><td></td><td>Honcho API key</td></tr>
        <tr><td><code>HONCHO_BASE_URL</code></td><td></td><td><code>https://api.honcho.dev</code></td><td>Honcho API endpoint</td></tr>
        <tr><td><code>HONCHO_WORKSPACE</code></td><td></td><td>Vault name</td><td>Honcho workspace ID. Should match the plugin's workspace.</td></tr>
        <tr><td><code>HONCHO_PEER</code></td><td>Yes</td><td></td><td>Your identity in Honcho (same as peerName in plugin/global config)</td></tr>
        <tr><td><code>OBSIDIAN_VAULT_PATH</code></td><td></td><td></td><td>Absolute path to vault. Required for filesystem transport.</td></tr>
        <tr><td><code>OBSIDIAN_TRANSPORT</code></td><td></td><td><code>auto</code></td><td><code>auto</code>, <code>cli</code>, <code>rest</code>, or <code>fs</code></td></tr>
        <tr><td><code>OBSIDIAN_REST_URL</code></td><td></td><td><code>http://127.0.0.1:27123</code></td><td>Local REST API plugin URL</td></tr>
        <tr><td><code>OBSIDIAN_REST_KEY</code></td><td></td><td></td><td>Local REST API plugin key</td></tr>
      </tbody>
    </table>
  </div>

  <h3>Full Stack (Setup 2 + Generic Honcho MCP)</h3>
  <p>Add the generic Honcho MCP alongside the Obsidian-Honcho MCP in your agent's configuration. The generic MCP is available at <code>mcp.honcho.dev</code> and provides workspace-agnostic operations: semantic search, chat, and conclusion creation.</p>
</section>

<!-- =============== STATUS =============== -->
<section id="status">
  <h2>Current Status</h2>

  <ul class="checklist">
    <li class="done">Plugin: 2-message ingestion (document context + body)</li>
    <li class="done">Plugin: FNV-1a content hashing and sync tracking</li>
    <li class="done">Plugin: Auto-sync with debounce + per-file cooldown</li>
    <li class="done">Plugin: Batch ingestion (folder, tag, linked neighborhood)</li>
    <li class="done">Plugin: Chat sidebar grounded in note context</li>
    <li class="done">Plugin: Frontmatter cleanup (dropped <code>honcho_</code> prefix)</li>
    <li class="done">Plugin: Single-peer model (collapsed observer/observed)</li>
    <li class="done">MCP: 9 tools (6 vault + 3 bridge)</li>
    <li class="done">MCP: Three-tier transport (CLI &gt; REST &gt; filesystem)</li>
    <li class="done">MCP: Filesystem transport (vault access without Obsidian running)</li>
    <li class="done">MCP: Lazy Honcho initialization (bridge tools only)</li>
    <li class="wip">MCP: End-to-end testing with Claude Desktop</li>
    <li class="todo">MCP: Publish as standalone package</li>
    <li class="todo">Plugin: Community plugin submission</li>
  </ul>

  <h3>Build Artifacts</h3>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Artifact</th><th>Size</th><th>Entry</th></tr></thead>
      <tbody>
        <tr><td>Obsidian Plugin</td><td>~109 KB</td><td><code>main.js</code></td></tr>
        <tr><td>MCP Server</td><td>~540 KB</td><td><code>mcp/server.ts</code></td></tr>
      </tbody>
    </table>
  </div>

  <h3>File Structure</h3>
  <pre><code>obsidian-honcho/
  src/                        <span class="cm"># Obsidian plugin source</span>
    commands/
      ingest.ts               <span class="cm"># 2-message ingestion pipeline</span>
      sync.ts                 <span class="cm"># Manual sync commands</span>
      feedback.ts             <span class="cm"># Experimental: conclusion feedback</span>
      search.ts               <span class="cm"># Conclusion search modal</span>
    utils/
      frontmatter.ts          <span class="cm"># Read/write sync tracking fields</span>
      sync-status.ts          <span class="cm"># Content hashing, staleness detection</span>
      sync-queue.ts           <span class="cm"># Debounced auto-sync queue</span>
    views/
      chat-modal.ts           <span class="cm"># Chat sidebar</span>
      sidebar-view.ts         <span class="cm"># Status + peer card</span>
    honcho-client.ts          <span class="cm"># Plugin's Honcho API client</span>
    settings.ts               <span class="cm"># Plugin settings UI</span>
    main.ts                   <span class="cm"># Plugin entry point</span>
  mcp/                        <span class="cm"># Standalone MCP server</span>
    server.ts                 <span class="cm"># MCP entry point (9-tool dispatch)</span>
    api.ts                    <span class="cm"># Unified transport (CLI/REST/fs)</span>
    cli.ts                    <span class="cm"># Obsidian CLI transport</span>
    rest.ts                   <span class="cm"># Local REST API transport</span>
    fs.ts                     <span class="cm"># Filesystem transport</span>
    honcho.ts                 <span class="cm"># Honcho API service (single-peer)</span>
    types.ts                  <span class="cm"># Tool schemas + config</span>
    tools/
      vault.ts                <span class="cm"># 5 vault tools</span>
      write.ts                <span class="cm"># vault_write</span>
      bridge.ts               <span class="cm"># 3 workspace bridge tools</span></code></pre>
</section>

</div><!-- .container -->

<!-- SCRIPTS -->
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  mermaid.initialize({
    startOnLoad: true,
    securityLevel: 'loose',
    fontFamily: 'Departure Mono, Noto Emoji, monospace',
  });
</script>

<script>
  // scroll progress bar
  window.addEventListener('scroll', () => {
    const bar = document.getElementById('progress');
    const max = document.documentElement.scrollHeight - window.innerHeight;
    const pct = max > 0 ? (window.scrollY / max) * 100 : 0;
    bar.style.width = pct + '%';
  });
</script>

</body>
</html>
