<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>obsidian-honcho: Architecture</title>
<style>
  /* ── Dark theme (default) — Kitty grays + Honcho/Kitty blues ── */
  :root, [data-theme="dark"] {
    --bg:             #181818;
    --bg-surface:     #232323;
    --bg-elevated:    #2F2F2F;
    --bg-code:        #141414;
    --fg:             #B7DBFF;
    --fg-bright:      #FFFFFF;
    --fg-muted:       #7C7C7C;
    --fg-subtle:      #5A5A5A;
    --accent:         #90CFFA;
    --accent-dim:     #0091EA;
    --accent-glow:    rgba(144, 207, 250, 0.08);
    --orange:         #e6a855;
    --red:            #f47067;
    --blue-bright:    #6FC2FB;
    --blue-light:     #B7DBFF;
    --blue-mid:       #29B6F6;
    --blue-deep:      #0091EA;
    --border:         #3A3A3A;
    --border-subtle:  #2A2A2A;
    --radius:         6px;
    --font-sans:      'New York', ui-serif, 'Iowan Old Style', 'Apple Garamond', Baskerville, 'Times New Roman', 'Noto Emoji', serif;
    --font-mono:      'Departure Mono', 'Noto Emoji', monospace;
    --toggle-icon:    "\263E";
  }

  /* ── Light theme ── */
  [data-theme="light"] {
    --bg:             #FFFFFF;
    --bg-surface:     #F9FAFB;
    --bg-elevated:    #F0F2F6;
    --bg-code:        #F0F2F6;
    --fg:             #374151;
    --fg-bright:      #111827;
    --fg-muted:       #6B7280;
    --fg-subtle:      #9CA3AF;
    --accent:         #0091EA;
    --accent-dim:     #B7DBFF;
    --accent-glow:    rgba(0, 145, 234, 0.06);
    --orange:         #C07D1C;
    --red:            #D32F2F;
    --blue-bright:    #0077C2;
    --blue-light:     #0091EA;
    --blue-mid:       #005BA1;
    --blue-deep:      #004C8C;
    --border:         #E5E7EB;
    --border-subtle:  #F3F4F6;
    --toggle-icon:    "\263C";
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  html { scroll-behavior: smooth; scroll-padding-top: 2rem; }

  body {
    font-family: var(--font-sans);
    background: var(--bg);
    color: var(--fg);
    line-height: 1.7;
    font-size: 15px;
    -webkit-font-smoothing: antialiased;
    transition: background 0.2s, color 0.2s;
  }

  .container { max-width: 860px; margin: 0 auto; padding: 3rem 2rem 6rem; }

  /* ── Theme toggle ── */
  .theme-toggle {
    position: fixed;
    top: 1rem;
    right: 1.5rem;
    z-index: 1000;
    width: 2rem;
    height: 2rem;
    border: 1px solid var(--border);
    border-radius: 3px;
    background: var(--bg-surface);
    color: var(--fg-muted);
    font-family: var(--font-mono);
    font-size: 1.1rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s, border-color 0.2s, color 0.2s;
    line-height: 1;
  }
  .theme-toggle:hover { border-color: var(--accent); color: var(--accent); }
  .theme-toggle::after { content: var(--toggle-icon); }

  .hero {
    text-align: center;
    padding: 4rem 0 2rem;
    margin-bottom: 2rem;
  }
  .hero h1 { font-family: var(--font-mono); font-size: 2.4rem; font-weight: 700; color: var(--fg-bright); letter-spacing: -0.03em; margin-bottom: 0.5rem; }
  .hero h1 span { color: var(--accent); }
  .hero .subtitle { font-family: var(--font-sans); color: var(--fg-muted); font-size: 0.92rem; max-width: 540px; margin: 0 auto; line-height: 1.6; }
  .hero .meta { margin-top: 1.5rem; display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
  .hero .meta span { font-size: 0.8rem; color: var(--fg-subtle); font-family: var(--font-mono); }
  .hero .meta span a { color: var(--accent-dim); text-decoration: none; }
  .hero .meta span a:hover { color: var(--accent); }

  .toc { background: var(--bg-surface); border: 1px solid var(--border); border-radius: var(--radius); padding: 1.5rem 2rem; margin-bottom: 3rem; transition: background 0.2s, border-color 0.2s; }
  .toc h2 { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--fg-muted); margin-bottom: 1rem; border-bottom: none; padding-bottom: 0; }
  .toc ol { list-style: none; counter-reset: toc; columns: 2; column-gap: 2rem; }
  .toc li { counter-increment: toc; break-inside: avoid; margin-bottom: 0.35rem; }
  .toc li::before { content: counter(toc, decimal-leading-zero) " "; color: var(--fg-subtle); font-family: var(--font-mono); font-size: 0.75rem; margin-right: 0.25rem; }
  .toc a { font-family: var(--font-mono); color: var(--fg); text-decoration: none; font-size: 0.82rem; transition: color 0.15s; }
  .toc a:hover { color: var(--accent); }

  section { margin-bottom: 4rem; }
  section + section { padding-top: 1rem; }

  h2 { font-family: var(--font-mono); font-size: 1.3rem; font-weight: 700; color: var(--fg-bright); letter-spacing: -0.01em; margin-bottom: 1.25rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); }
  h3 { font-family: var(--font-mono); font-size: 1rem; font-weight: 600; color: var(--fg-bright); margin-top: 2rem; margin-bottom: 0.75rem; }
  h4 { font-family: var(--font-mono); font-size: 0.9rem; font-weight: 600; color: var(--accent); margin-top: 1.5rem; margin-bottom: 0.5rem; }

  p { margin-bottom: 1rem; font-size: 0.95rem; line-height: 1.75; }
  strong { color: var(--fg-bright); font-weight: 600; }
  a { color: var(--accent); text-decoration: none; }
  a:hover { text-decoration: underline; }

  ul, ol { margin-bottom: 1rem; padding-left: 1.5rem; font-size: 0.93rem; line-height: 1.7; }
  li { margin-bottom: 0.35rem; }
  li::marker { color: var(--fg-subtle); }

  .table-wrap { overflow-x: auto; margin-bottom: 1.5rem; }
  table { width: 100%; border-collapse: collapse; font-size: 0.88rem; }
  th, td { text-align: left; padding: 0.6rem 1rem; border-bottom: 1px solid var(--border-subtle); }
  th { font-family: var(--font-mono); font-size: 0.72rem; text-transform: uppercase; letter-spacing: 0.06em; color: var(--fg-muted); background: var(--bg-surface); border-bottom-color: var(--border); white-space: nowrap; }
  td { font-family: var(--font-sans); font-size: 0.88rem; color: var(--fg); }
  tr:hover td { background: var(--accent-glow); }
  td code { background: var(--bg-elevated); padding: 0.15em 0.4em; border-radius: 3px; font-family: var(--font-mono); font-size: 0.82em; color: var(--blue-bright); }

  pre { background: var(--bg-code); border: 1px solid var(--border); border-radius: var(--radius); padding: 1.25rem 1.5rem; overflow-x: auto; margin-bottom: 1.5rem; font-family: var(--font-mono); font-size: 0.82rem; line-height: 1.65; color: var(--fg); transition: background 0.2s, border-color 0.2s; }
  pre code { background: none; padding: 0; color: inherit; font-size: inherit; }
  code { font-family: var(--font-mono); font-size: 0.85em; }
  p code, li code { background: var(--bg-elevated); padding: 0.15em 0.4em; border-radius: 3px; color: var(--blue-bright); font-size: 0.85em; }

  .kw { color: var(--blue-mid); } .str { color: var(--blue-light); } .cm { color: var(--fg-subtle); font-style: italic; } .num { color: var(--orange); } .key { color: var(--accent); } .fn { color: var(--blue-bright); }

  .mermaid { margin: 2rem -10%; padding: 1.5rem 0; text-align: center; width: 120%; }
  .mermaid svg { max-width: 100%; height: auto; }

  .callout { font-family: var(--font-sans); background: var(--bg-surface); border-left: 3px solid var(--accent-dim); border-radius: 0 var(--radius) var(--radius) 0; padding: 1rem 1.25rem; margin-bottom: 1.5rem; font-size: 0.88rem; color: var(--fg-muted); line-height: 1.6; transition: background 0.2s, border-color 0.2s; }
  .callout strong { font-family: var(--font-mono); color: var(--fg-bright); }
  .callout.success { border-left-color: var(--accent-dim); }
  .callout.warn { border-left-color: var(--orange); }

  .badge { display: inline-block; font-family: var(--font-mono); font-size: 0.65rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; padding: 0.2em 0.6em; border-radius: 3px; vertical-align: middle; margin-left: 0.4rem; }
  .badge-done { background: var(--accent-dim); color: #fff; }
  .badge-wip { background: var(--orange); color: #0b0e14; }
  .badge-todo { background: var(--fg-subtle); color: var(--fg); }

  .checklist { list-style: none; padding-left: 0; }
  .checklist li { padding-left: 1.5rem; position: relative; margin-bottom: 0.5rem; }
  .checklist li::before { position: absolute; left: 0; font-family: var(--font-mono); font-size: 0.85rem; }
  .checklist li.done { color: var(--fg-muted); }
  .checklist li.done::before { content: "\2713"; color: var(--accent); }
  .checklist li.todo::before { content: "\25CB"; color: var(--fg-subtle); }
  .checklist li.wip::before { content: "\25D4"; color: var(--orange); }

  hr { border: none; border-top: 1px solid var(--border); margin: 3rem 0; }

  @media (max-width: 640px) {
    .container { padding: 2rem 1rem 4rem; }
    .hero h1 { font-size: 1.6rem; }
    .toc ol { columns: 1; }
    table { font-size: 0.8rem; }
    th, td { padding: 0.4rem 0.6rem; }
    .theme-toggle { top: 0.5rem; right: 0.75rem; }
  }

  .progress-bar { position: fixed; top: 0; left: 0; height: 2px; background: var(--accent); z-index: 999; transition: width 0.1s linear; }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Emoji&display=swap" rel="stylesheet">
<style>
  @font-face {
    font-family: 'Departure Mono';
    src: url('https://cdn.jsdelivr.net/gh/rektdeckard/departure-mono@latest/fonts/DepartureMono-Regular.woff2') format('woff2');
    font-weight: normal; font-style: normal; font-display: swap;
  }
</style>
</head>
<body>

<div class="progress-bar" id="progress"></div>
<button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme"></button>

<div class="container">

<!-- =============== HERO =============== -->
<header class="hero">
  <h1>obsidian<span>-honcho</span></h1>
  <p class="subtitle">How the act of writing becomes identity. A bidirectional bridge between Obsidian's structural knowledge and Honcho's memory platform.</p>
  <div class="meta">
    <span><a href="https://github.com/erosika/obsidian-honcho">erosika/obsidian-honcho</a></span>
    <span>TypeScript / Obsidian Plugin</span>
    <span>v0.1.0</span>
    <span>February 2026</span>
  </div>
</header>

<!-- =============== TOC =============== -->
<nav class="toc">
  <h2>Contents</h2>
  <ol>
    <li><a href="#data-flow">Data Flow &amp; Core Thesis</a></li>
    <li><a href="#ingestion">Ingestion &amp; Structural Signals</a></li>
    <li><a href="#observation">Observation &amp; Dreaming</a></li>
    <li><a href="#peer-architecture">Peer Architecture</a></li>
    <li><a href="#sync-intelligence">Sync Intelligence</a></li>
    <li><a href="#feedback-loop">Feedback Loop</a></li>
    <li><a href="#chat">Streaming Chat</a></li>
    <li><a href="#sidebar">Sidebar &amp; Rendering</a></li>
    <li><a href="#session-lifecycle">Session Lifecycle</a></li>
    <li><a href="#configuration">Configuration</a></li>
    <li><a href="#file-structure">File Structure</a></li>
    <li><a href="#progress">Progress</a></li>
    <li><a href="#demo">Demo: First Note to Identity</a></li>
    <li><a href="#cli-integration">CLI &amp; MCP Server</a></li>
    <li><a href="#api-proposals">P.S. &mdash; API Surface</a></li>
  </ol>
</nav>

<!-- =============== DATA FLOW =============== -->
<section id="data-flow">
  <h2>Data Flow &amp; Core Thesis</h2>

  <p>Every note, tag, link, and folder is a signal about who you are and how you think. The plugin makes that signal legible to Honcho &mdash; and Honcho feeds back consolidated identity. Two ingestion paths: the <strong>plugin</strong> runs inside Obsidian's runtime via REST API calls; the <strong>MCP server</strong> (<code>mcp/</code>) runs as a standalone Bun process, wrapping the Obsidian CLI for external agents. Both feed the same Honcho workspace.</p>

  <div class="mermaid">
%%{init: {'theme': 'dark', 'themeVariables': { 'primaryColor': '#1f3150', 'primaryTextColor': '#c9d1d9', 'primaryBorderColor': '#3d6ea5', 'lineColor': '#3d6ea5', 'secondaryColor': '#162030', 'tertiaryColor': '#11151c', 'edgeLabelBackground': '#0b0e14', 'fontSize': '14px' }, 'flowchart': { 'nodeSpacing': 30, 'rankSpacing': 40 }}}%%
flowchart LR
    V["Vault"] -->|strip + hash| P["Sessions"]
    P --> O["Observe + Dream"]
    O --> C["Conclusions"]
    C --> R["Represent"]
    R -->|sync back| V
    C -->|feedback| V
    R <-->|dialectic| Q["Chat"]

    style V fill:#162030,stroke:#7eb8f6,color:#c9d1d9
    style P fill:#1f3150,stroke:#3d6ea5,color:#c9d1d9
    style O fill:#11151c,stroke:#3d6ea5,color:#c9d1d9
    style C fill:#11151c,stroke:#3d6ea5,color:#c9d1d9
    style R fill:#11151c,stroke:#3d6ea5,color:#c9d1d9
    style Q fill:#1f3150,stroke:#3d6ea5,color:#c9d1d9
  </div>

  <h3>Vault &#x2192; Honcho</h3>
  <ul>
    <li><strong>Strip</strong> &mdash; <code>stripForIngestion()</code> removes frontmatter + any existing <code>## Honcho</code> feedback section before hashing or sending</li>
    <li><strong>Hash</strong> &mdash; FNV-1a (8 hex chars) on the stripped body. Unchanged content is skipped</li>
    <li><strong>Preamble</strong> &mdash; structural context (tags, links, backlinks, graph position, headings, dates, custom properties) as the first session message</li>
    <li><strong>Chunk</strong> &mdash; markdown split at heading/paragraph/sentence boundaries (~2000 chars), each as a message</li>
    <li><strong>Session</strong> &mdash; deterministic ID <code>obsidian:file:{path}</code>. Re-ingest deletes and recreates the session fresh</li>
  </ul>

  <h3>Honcho &#x2192; Vault</h3>
  <ul>
    <li><strong>Frontmatter</strong> &mdash; <code>honcho_synced</code>, <code>honcho_session_id</code>, <code>honcho_message_count</code>, <code>honcho_content_hash</code> written atomically</li>
    <li><strong>Identity notes</strong> &mdash; peer card + representation as vault documents, tagged <code>#honcho/identity</code></li>
    <li><strong>Conclusions notes</strong> &mdash; all observations pulled into a document, tagged <code>#honcho/conclusions</code></li>
    <li><strong>Feedback section</strong> &mdash; <code>## Honcho</code> appended to ingested notes with relevant conclusions</li>
    <li><strong>Chat</strong> &mdash; streaming dialectic grounded in vault-derived identity, saveable as notes or appended to the daily note</li>
  </ul>
</section>


<!-- =============== INGESTION =============== -->
<section id="ingestion">
  <h2>Ingestion &amp; Structural Signals</h2>

  <p>Every ingested note begins with a structural preamble &mdash; a machine-readable summary of the note's position in the knowledge graph. This grounds every subsequent content chunk in context.</p>

  <h3>Preamble format</h3>
  <pre><code>[Note: Core Values]
Aliases: core-values, CV
Folder: identity/core
Tags: #identity, #philosophy, #values
status: active
Structure: # Core Values > ## Integrity > ## Curiosity
Links to: Stoicism, Marcus Aurelius
Referenced by: Daily Notes/2026-02-01, Vision Document
Backlink count: 7
Graph position: hub
Created: 2025-11-15
Modified: 2026-02-09</code></pre>

  <h3>Signals extracted</h3>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Signal</th><th>Source</th></tr></thead>
      <tbody>
        <tr><td>Tags</td><td><code>metadataCache.tags</code> + frontmatter</td></tr>
        <tr><td>Aliases, custom properties</td><td>All frontmatter keys minus internal keys</td></tr>
        <tr><td>Headings</td><td><code>cache.headings[]</code></td></tr>
        <tr><td>Outgoing links</td><td><code>cache.links[]</code></td></tr>
        <tr><td>Backlinks + count</td><td>Inverted <code>resolvedLinks</code></td></tr>
        <tr><td>Graph position</td><td>Computed: <code>hub</code> / <code>orphan</code> / <code>dead-end</code> / <code>isolated</code> / <code>connected</code></td></tr>
        <tr><td>Unresolved links</td><td>Wiki-links with no target file</td></tr>
        <tr><td>Folder, created, modified</td><td><code>file.parent.path</code>, <code>file.stat</code></td></tr>
      </tbody>
    </table>
  </div>

  <h3>Graph-aware traversal</h3>
  <p>"Ingest + linked notes" does BFS over outgoing wiki-links up to configurable depth (1&ndash;3). Links resolved via <code>getFirstLinkpathDest()</code>; only <code>.md</code> files followed. Each file respects sync status &mdash; unchanged files skipped. A dream is scheduled after traversal completes.</p>

  <h3>Batch ingestion</h3>
  <p>Folder and tag ingestion use <code>partitionByStatus()</code> to classify all files upfront (new / modified / unchanged), then only process files that need sync. Batched 5 at a time with progress reporting.</p>
</section>

<!-- =============== OBSERVATION =============== -->
<section id="observation">
  <h2>Observation &amp; Dreaming</h2>

  <p>Once messages land in Honcho, the observation pipeline takes over (no plugin code involved).</p>

  <div class="mermaid">
%%{init: {'theme': 'dark', 'themeVariables': { 'primaryColor': '#1f3150', 'primaryTextColor': '#c9d1d9', 'primaryBorderColor': '#3d6ea5', 'lineColor': '#3d6ea5', 'secondaryColor': '#162030', 'tertiaryColor': '#11151c', 'edgeLabelBackground': '#0b0e14', 'fontSize': '14px' }, 'flowchart': { 'nodeSpacing': 30, 'rankSpacing': 40 }}}%%
flowchart LR
    M["Messages"] --> B["Batch + Derive"]
    B --> C["Conclusions"]
    C -->|"> 50"| DR["Dream"]
    DR --> PC["Peer Card"]

    style M fill:#162030,stroke:#3d6ea5,color:#c9d1d9
    style B fill:#1f3150,stroke:#3d6ea5,color:#c9d1d9
    style C fill:#11151c,stroke:#3d6ea5,color:#c9d1d9
    style DR fill:#11151c,stroke:#7eb8f6,color:#c9d1d9
    style PC fill:#11151c,stroke:#7eb8f6,color:#c9d1d9
  </div>

  <p>The queue manager batches messages by tokens (threshold: 1024). The deriver generates observations with structural preambles as context. When conclusions exceed 50, dreaming fires: surprisal sampling &#x2192; deduction (up to 12 iterations) &#x2192; induction (up to 10 iterations) &#x2192; peer card update.</p>

  <div class="callout success">
    <strong>Automatic dream scheduling.</strong> After bulk ingestion (folder, tag, or linked-note traversal), the plugin calls <code>scheduleDream()</code> to bypass the idle timeout. Also available as a manual command.
  </div>

  <p>Each ingestion session enables <code>reasoning</code>, <code>dream</code>, and <code>summary</code> in its configuration.</p>
</section>

<!-- =============== PEER ARCHITECTURE =============== -->
<section id="peer-architecture">
  <h2>Peer Architecture</h2>
  <p>Honcho uses an observer/observed model: the <strong>observer</strong> is the tool sending material, the <strong>observed</strong> is the person whose identity is being built. All note content is attributed to the observed peer &mdash; your writing becomes <em>their</em> signal.</p>

  <div class="table-wrap">
    <table>
      <thead><tr><th>Role</th><th>Peer</th><th>Flags</th><th>What it does</th></tr></thead>
      <tbody>
        <tr><td>Observer</td><td><code>obsidian</code></td><td><code>observe_others: true</code></td><td>The plugin &mdash; sends notes, schedules dreams, reads back identity</td></tr>
        <tr><td>Observed</td><td><code>obsidian</code> (default) or configured name</td><td><code>observe_me: true</code></td><td>The person &mdash; whose identity Honcho builds from the notes</td></tr>
      </tbody>
    </table>
  </div>

  <p>In the default configuration, both roles use the same peer name (<code>obsidian</code>). This is the simplest setup &mdash; one vault, one identity. If you set <strong>Observed peer</strong> to a different name in settings, the vault becomes a dedicated observer feeding material into that peer's identity. Multiple observers (different vaults, apps, or agents) can all contribute to the same observed peer.</p>

  <p>Peers are initialized lazily via <code>ensureInitialized()</code> before the first operation. Both <code>getOrCreateWorkspace()</code> and <code>getOrCreatePeer()</code> are idempotent.</p>
</section>

<!-- =============== SYNC INTELLIGENCE =============== -->
<section id="sync-intelligence">
  <h2>Sync Intelligence</h2>
  <p>Content is never re-ingested unless it has actually changed. Multiple layers prevent redundant API calls.</p>

  <h3>Content hashing &amp; stripping</h3>
  <p><code>stripForIngestion()</code> chains <code>stripFrontmatter()</code> + <code>stripHonchoSection()</code>, then FNV-1a hashes the result. The hash is stored as <code>honcho_content_hash</code>. This means: (a) Honcho never sees its own feedback output; (b) hashes are stable regardless of feedback state; (c) frontmatter-only changes don't trigger re-ingestion.</p>

  <h3>Sync status</h3>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Status</th><th>Condition</th><th>Action</th></tr></thead>
      <tbody>
        <tr><td><code>new</code></td><td>No <code>honcho_synced</code></td><td>Ingest</td></tr>
        <tr><td><code>modified</code></td><td>Hash differs from stored</td><td>Ingest</td></tr>
        <tr><td><code>unchanged</code></td><td>Hash matches</td><td>Skip</td></tr>
      </tbody>
    </table>
  </div>

  <h3>Auto-sync queue</h3>
  <p>A centralized <code>SyncQueue</code> replaces naive per-file debounce timers:</p>
  <ul>
    <li>5s debounce per file; priority by backlink count (hubs first) + new-file bonus</li>
    <li>3 concurrent; retry up to 2x with priority decay</li>
    <li>Tag/folder filter matching via <code>matchesSyncFilters()</code></li>
    <li>File renames and deletes clear pending queue entries</li>
  </ul>

  <h3>Stale notes</h3>
  <p>"Show stale notes" scans the vault for notes where <code>honcho_content_hash</code> doesn't match the current hash. Results shown in a modal with batch re-ingest.</p>
</section>

<!-- =============== FEEDBACK LOOP =============== -->
<section id="feedback-loop">
  <h2>Feedback Loop</h2>
  <p>Off by default. When enabled, derived conclusions are written back as a <code>## Honcho</code> section at the bottom of ingested notes. Opt-in globally via settings, override per note via frontmatter.</p>

  <h3>Resolution</h3>
  <ul>
    <li><code>honcho_generated</code> in frontmatter &rarr; always skip (plugin-created notes)</li>
    <li><code>honcho_feedback: false</code> &rarr; disabled (even if global on)</li>
    <li><code>honcho_feedback: true</code> &rarr; enabled (even if global off)</li>
    <li>Absent &rarr; falls through to global <code>feedbackLoop</code> setting</li>
  </ul>

  <h3>Fetching</h3>
  <p>Session-scoped first (<code>listConclusions</code> by session ID, up to 20). If empty, falls back to semantic search (<code>queryConclusions</code> by note title, top 10).</p>

  <h3>Format</h3>
  <p>First conclusion as blockquote, rest as list items, with an ISO timestamp for staleness checking. Written atomically via <code>vault.process()</code> which strips any existing section then appends the new one.</p>

  <h3>Triggers</h3>
  <ol>
    <li><strong>Explicit</strong> &mdash; "Update Honcho feedback" command or file menu item</li>
    <li><strong>Lazy on file open</strong> &mdash; 2s delay, only if section missing or stale (&gt;1 hour)</li>
    <li><strong>Post-ingest deferred</strong> &mdash; 60s after ingest, checks if observation queue is clear</li>
  </ol>

  <h3>Guard rails</h3>
  <p>Two independent layers: <code>writingFeedbackPaths</code> guard set (parallel to <code>ingestingPaths</code>) prevents re-entrant modify events; <code>stripForIngestion()</code> ensures the section is always removed before content reaches Honcho.</p>
</section>

<!-- =============== CHAT =============== -->
<section id="chat">
  <h2>Streaming Chat</h2>
  <p>SSE streaming via native <code>fetch()</code> (bypasses <code>requestUrl</code>'s lack of streaming support). Each delta re-renders markdown via <code>MarkdownRenderer.render()</code>. Falls back to non-streaming if SSE fails. <code>AbortController</code> for cancellation.</p>

  <h3>Reasoning levels</h3>
  <p><code>minimal</code> / <code>low</code> / <code>medium</code> (default) / <code>high</code> / <code>max</code> &mdash; controls depth of dialectic reasoning.</p>

  <h3>Contextual mode</h3>
  <p>"Chat about this note" pre-seeds with title, tags, headings, links, backlinks, properties, and a content excerpt (~500 chars). If the note is ingested, the session ID grounds the dialectic in the note's specific content. Conversations are saveable as vault notes or appendable to the daily note.</p>
</section>

<!-- =============== SIDEBAR =============== -->
<section id="sidebar">
  <h2>Sidebar &amp; Rendering</h2>

  <h3>Identity sidebar</h3>
  <p>Uses <code>getPeerContext</code> (single API call for card + representation). Tracks active note via <code>active-leaf-change</code> &mdash; when viewing a markdown file, shows a focused representation using the note's title, tags, and headings as <code>search_query</code>. Debounced to avoid API spam. Connection test cached 60s; stale count cached 30s.</p>

  <h3>Conclusion explorer</h3>
  <p>Newest/Oldest sort chips, live text filter, count display ("12 of 47"), pagination (20 per page).</p>

  <h3>Inline code blocks</h3>
  <p>A <code>honcho</code> code block processor renders live data in reading view:</p>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Block</th><th>Renders</th></tr></thead>
      <tbody>
        <tr><td><code>search: values</code> + <code>limit: 5</code></td><td>Semantic search results with dates</td></tr>
        <tr><td><code>card</code></td><td>Peer card as bullets</td></tr>
        <tr><td><code>representation</code></td><td>Full representation as markdown</td></tr>
        <tr><td><code>conclusions 10</code></td><td>N most recent conclusions</td></tr>
      </tbody>
    </table>
  </div>

  <h3>Peer card authorship</h3>
  <p>"Push note as peer card" parses bullet points from a note and PUTs them via <code>setPeerCard</code>. Direct identity authorship &mdash; no pipeline intermediary.</p>
</section>

<!-- =============== SESSION LIFECYCLE =============== -->
<section id="session-lifecycle">
  <h2>Session Lifecycle</h2>

  <p>Sessions use deterministic IDs: <code>obsidian:file:{relative_path}</code>. Re-ingestion deletes and recreates the session to prevent message accumulation.</p>

  <ul>
    <li><strong>Rename</strong> &mdash; catches <code>vault.rename</code>, updates session metadata (<code>file_path</code>, <code>file_name</code>, <code>folder</code>, <code>renamed_from</code>, <code>renamed_at</code>), clears sync queue</li>
    <li><strong>Delete</strong> &mdash; catches <code>vault.delete</code>, soft-marks session (<code>deleted_from_vault: true</code>) to preserve conclusions, clears sync queue</li>
    <li><strong>Daily notes</strong> &mdash; when <code>autoSyncDailyNotes</code> is on, opening a daily note auto-enqueues it. Detected via the internal <code>daily-notes</code> plugin configuration (folder + date format length match)</li>
    <li><strong>Session manager</strong> &mdash; modal with queue progress bar, session list with pagination, re-ingest/delete/dream buttons</li>
  </ul>
</section>

<!-- =============== CONFIGURATION =============== -->
<section id="configuration">
  <h2>Configuration</h2>

  <h3>Settings (13)</h3>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Setting</th><th>Default</th><th>Description</th></tr></thead>
      <tbody>
        <tr><td><code>apiKey</code></td><td>&mdash;</td><td>Honcho API key (masked)</td></tr>
        <tr><td><code>baseUrl</code></td><td><code>https://api.honcho.dev</code></td><td>API endpoint</td></tr>
        <tr><td><code>apiVersion</code></td><td><code>v3</code></td><td>API version prefix</td></tr>
        <tr><td><code>workspaceName</code></td><td>(vault name)</td><td>Workspace ID</td></tr>
        <tr><td><code>peerName</code></td><td><code>obsidian</code></td><td>Observer peer</td></tr>
        <tr><td><code>observedPeerName</code></td><td>(= observer)</td><td>Observed peer</td></tr>
        <tr><td><code>linkDepth</code></td><td><code>1</code></td><td>Graph traversal depth (1&ndash;3)</td></tr>
        <tr><td><code>autoSync</code></td><td><code>false</code></td><td>Auto-ingest on save</td></tr>
        <tr><td><code>autoSyncTags</code></td><td><code>[]</code></td><td>Tag filter</td></tr>
        <tr><td><code>autoSyncFolders</code></td><td><code>[]</code></td><td>Folder filter</td></tr>
        <tr><td><code>autoSyncDailyNotes</code></td><td><code>false</code></td><td>Auto-ingest daily notes on open</td></tr>
        <tr><td><code>trackFrontmatter</code></td><td><code>true</code></td><td>Write sync metadata to notes</td></tr>
        <tr><td><code>feedbackLoop</code></td><td><code>false</code></td><td>Write ## Honcho section</td></tr>
      </tbody>
    </table>
  </div>

  <h3>Frontmatter</h3>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Field</th><th>Written by</th><th>Description</th></tr></thead>
      <tbody>
        <tr><td><code>honcho_synced</code></td><td>Plugin</td><td>Last ingestion timestamp</td></tr>
        <tr><td><code>honcho_session_id</code></td><td>Plugin</td><td>Session ID</td></tr>
        <tr><td><code>honcho_message_count</code></td><td>Plugin</td><td>Messages sent</td></tr>
        <tr><td><code>honcho_content_hash</code></td><td>Plugin</td><td>FNV-1a body hash</td></tr>
        <tr><td><code>honcho_feedback</code></td><td>User</td><td>Per-note feedback override</td></tr>
        <tr><td><code>honcho_generated</code></td><td>Plugin</td><td>Marks plugin-created notes</td></tr>
      </tbody>
    </table>
  </div>

  <h3>Commands (15)</h3>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Command</th><th>Context</th></tr></thead>
      <tbody>
        <tr><td>Open Honcho sidebar</td><td>Global</td></tr>
        <tr><td>Ingest current note</td><td>Active file</td></tr>
        <tr><td>Ingest current note + linked notes</td><td>Active file</td></tr>
        <tr><td>Ingest folder</td><td>Global (picker)</td></tr>
        <tr><td>Ingest notes by tag</td><td>Global (picker)</td></tr>
        <tr><td>Chat with Honcho</td><td>Global</td></tr>
        <tr><td>Chat with Honcho about this note</td><td>Active file</td></tr>
        <tr><td>Search Honcho memory</td><td>Global</td></tr>
        <tr><td>Manage sessions</td><td>Global</td></tr>
        <tr><td>Generate identity note</td><td>Global</td></tr>
        <tr><td>Pull conclusions into vault</td><td>Global</td></tr>
        <tr><td>Push note as peer card</td><td>Active file</td></tr>
        <tr><td>Schedule Honcho dream</td><td>Global</td></tr>
        <tr><td>Show stale notes</td><td>Global</td></tr>
        <tr><td>Update Honcho feedback</td><td>Active file</td></tr>
      </tbody>
    </table>
  </div>
</section>

<!-- =============== FILE STRUCTURE =============== -->
<section id="file-structure">
  <h2>File Structure</h2>
  <pre><code>src/
&#x251C;&#x2500;&#x2500; main.ts                <span class="cm"># Plugin lifecycle, 15 commands, events, guard sets</span>
&#x251C;&#x2500;&#x2500; settings.ts            <span class="cm"># Settings interface + tab</span>
&#x251C;&#x2500;&#x2500; honcho-client.ts       <span class="cm"># REST client with retry, streaming, dreams</span>
&#x251C;&#x2500;&#x2500; views/
&#x2502;   &#x251C;&#x2500;&#x2500; sidebar-view.ts    <span class="cm"># Identity sidebar + conclusion explorer</span>
&#x2502;   &#x251C;&#x2500;&#x2500; chat-modal.ts      <span class="cm"># Streaming dialectic chat</span>
&#x2502;   &#x251C;&#x2500;&#x2500; session-manager.ts <span class="cm"># Session list + queue status</span>
&#x2502;   &#x251C;&#x2500;&#x2500; stale-notes-modal.ts <span class="cm"># Stale notes + batch re-ingest</span>
&#x2502;   &#x2514;&#x2500;&#x2500; post-processor.ts  <span class="cm"># honcho code block renderer</span>
&#x251C;&#x2500;&#x2500; commands/
&#x2502;   &#x251C;&#x2500;&#x2500; ingest.ts          <span class="cm"># Structural ingestion + graph traversal</span>
&#x2502;   &#x251C;&#x2500;&#x2500; sync.ts            <span class="cm"># Pull identity/conclusions, push peer card</span>
&#x2502;   &#x251C;&#x2500;&#x2500; search.ts          <span class="cm"># Unified search (conclusions + messages)</span>
&#x2502;   &#x2514;&#x2500;&#x2500; feedback.ts        <span class="cm"># Conclusion fetching + atomic writing</span>
&#x2514;&#x2500;&#x2500; utils/
    &#x251C;&#x2500;&#x2500; chunker.ts         <span class="cm"># Markdown splitting (2000-char target)</span>
    &#x251C;&#x2500;&#x2500; frontmatter.ts     <span class="cm"># Frontmatter read/write/filter</span>
    &#x251C;&#x2500;&#x2500; sync-status.ts     <span class="cm"># Hashing, stripping, stale detection</span>
    &#x2514;&#x2500;&#x2500; sync-queue.ts      <span class="cm"># Priority queue with debounce + retry</span>

mcp/                           <span class="cm"># Standalone MCP server (Bun)</span>
&#x251C;&#x2500;&#x2500; server.ts              <span class="cm"># Entry point + 9-tool dispatch</span>
&#x251C;&#x2500;&#x2500; cli.ts                 <span class="cm"># Obsidian CLI via Bun.spawn() (array args, no shell)</span>
&#x251C;&#x2500;&#x2500; chunk.ts               <span class="cm"># Markdown chunking + stripForIngestion + FNV-1a hash</span>
&#x251C;&#x2500;&#x2500; honcho.ts              <span class="cm"># HonchoService: lazy init, session CRUD, messages, dreams</span>
&#x251C;&#x2500;&#x2500; types.ts               <span class="cm"># Errors, config, 9 tool schemas</span>
&#x2514;&#x2500;&#x2500; tools/
    &#x251C;&#x2500;&#x2500; vault.ts           <span class="cm"># vault_read, vault_search, vault_info, vault_list, vault_graph</span>
    &#x251C;&#x2500;&#x2500; write.ts           <span class="cm"># vault_write (create/append/prepend/move/delete/properties)</span>
    &#x2514;&#x2500;&#x2500; integrate.ts       <span class="cm"># vault_ingest, vault_contextualize, vault_status</span></code></pre>
</section>

<!-- =============== PROGRESS =============== -->
<section id="progress">
  <h2>Progress</h2>
  <ul class="checklist">
    <li class="done">REST client with retry (3x exponential backoff) + SSE streaming</li>
    <li class="done">Structural ingestion: tags, links, backlinks, graph intelligence, aliases, custom properties</li>
    <li class="done">Graph-aware BFS traversal with configurable depth</li>
    <li class="done">Content hashing (FNV-1a) + stripping pipeline</li>
    <li class="done">Priority sync queue (debounce, backlink priority, batch, retry)</li>
    <li class="done">Batch partitioning + stale notes detection</li>
    <li class="done">Session lifecycle: rename tracking, delete handling, deterministic IDs</li>
    <li class="done">Streaming chat with reasoning levels + contextual mode</li>
    <li class="done">Sidebar: peer context, conclusion explorer, contextual representation</li>
    <li class="done"><code>honcho</code> code block processor (search, card, representation, conclusions)</li>
    <li class="done">Bidirectional sync: identity notes, conclusions, peer card authorship</li>
    <li class="done">Feedback loop (## Honcho section, per-note override, 3 triggers, guard rails)</li>
    <li class="done">Daily note integration (auto-sync on open, append to daily)</li>
    <li class="done">Dream scheduling (auto after bulk + manual command)</li>
    <li class="done">Unified search (conclusions + messages with source links)</li>
    <li class="done">MCP server: 9 tools (6 vault + 3 bridge), staleness via session metadata hash</li>
    <li class="todo">EditorSuggest integration (inline autocomplete)</li>
    <li class="todo">Status bar sync indicator</li>
    <li class="todo">Bases views integration (1.10.0+)</li>
  </ul>
</section>

<!-- =============== DEMO WALKTHROUGH =============== -->
<section id="demo">
  <h2>Demo: First Note to Identity</h2>
  <p>End-to-end walkthrough of a single note's lifecycle.</p>

  <h3>The note</h3>
  <pre><code><span class="cm">---</span>
<span class="key">tags</span>: [philosophy, stoicism]
<span class="key">aliases</span>: [stoic-practice]
<span class="cm">---</span>

<span class="str"># Daily Stoic Practice</span>

Morning journaling is where I process decisions before the day starts.
I write about what I can control and release what I can't.

<span class="str">## Why This Matters</span>

It's not about suppressing emotion. It's about clarity under pressure.
[[Marcus Aurelius]] called it the "inner citadel."
Links to my [[Core Values]] and [[Decision Framework]].</code></pre>

  <h3>What the plugin sends</h3>
  <p>Session <code>obsidian:file:philosophy/Daily Stoic Practice.md</code> receives two messages, both attributed to the observed peer:</p>

  <pre><code><span class="cm"># Message 1: structural preamble</span>
[Note: Daily Stoic Practice]
Aliases: stoic-practice
Folder: philosophy
Tags: #philosophy, #stoicism
Structure: # Daily Stoic Practice > ## Why This Matters
Links to: Marcus Aurelius, Core Values, Decision Framework
Referenced by: Morning Routine, Reading List
Backlink count: 2 | Graph position: connected
Created: 2026-01-15 | Modified: 2026-02-18

<span class="cm"># Message 2: note body (frontmatter stripped, hash a3f1c802)</span></code></pre>

  <h3>What Honcho returns</h3>
  <p>Observation derives conclusions. After enough accumulate, dreaming consolidates into the peer card.</p>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Stage</th><th>Output</th></tr></thead>
      <tbody>
        <tr><td>Conclusions</td><td><em>"Uses morning journaling as a pre-decision processing tool"</em></td></tr>
        <tr><td>Conclusions</td><td><em>"Draws on Stoic philosophy for emotional regulation &mdash; clarity, not suppression"</em></td></tr>
        <tr><td>Conclusions</td><td><em>"References Marcus Aurelius' 'inner citadel' as a personal anchor"</em></td></tr>
        <tr><td>Peer card</td><td><em>"Practices Stoic philosophy as daily discipline, not intellectual exercise"</em></td></tr>
      </tbody>
    </table>
  </div>

  <h3>What the vault gets back</h3>
  <p>Frontmatter is updated with sync metadata. If <code>feedbackLoop</code> is enabled (off by default), the note also receives:</p>
  <pre><code><span class="str">## Honcho</span>

> Uses morning journaling as a pre-decision processing tool

- Draws on Stoic philosophy for emotional regulation
- References Marcus Aurelius' "inner citadel" as personal anchor

<span class="cm">*Last updated: 2026-02-18T11:05:00Z*</span></code></pre>

  <p>On re-edit, the <code>## Honcho</code> section is stripped before hashing &mdash; a changed body produces a new hash, triggers re-ingestion. The feedback section is never sent to Honcho.</p>
</section>

<!-- =============== CLI & MCP SERVER =============== -->
<section id="cli-integration">
  <h2>CLI &amp; MCP Server</h2>
  <p>The plugin runs inside Obsidian's plugin runtime using internal JS APIs. External agents access the vault through the <strong>MCP server</strong> (<code>mcp/</code>) &mdash; a standalone Bun process that wraps the Obsidian CLI into 9 structured tools, 6 pure vault and 3 that bridge vault + Honcho.</p>

  <h3>MCP tools (9)</h3>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Tool</th><th>Type</th><th>What it does</th></tr></thead>
      <tbody>
        <tr><td><code>vault_read</code></td><td>Vault</td><td>Read raw note content</td></tr>
        <tr><td><code>vault_write</code></td><td>Vault</td><td>Create, append, prepend, move, delete, properties, bookmark, daily append</td></tr>
        <tr><td><code>vault_search</code></td><td>Vault</td><td>Keyword search via CLI (semantic search at <code>mcp.honcho.dev</code>)</td></tr>
        <tr><td><code>vault_info</code></td><td>Vault</td><td>7 parallel CLI calls: metadata, backlinks, links, outline, properties, tags, aliases</td></tr>
        <tr><td><code>vault_list</code></td><td>Vault</td><td>List files with folder/ext/total filters</td></tr>
        <tr><td><code>vault_graph</code></td><td>Vault</td><td>Orphans, deadends, unresolved, tags, recents, tasks in parallel</td></tr>
        <tr><td><code>vault_ingest</code></td><td>Bridge</td><td>Full pipeline: strip, hash, staleness check, preamble, chunk, session, messages, dream. Modes: file, folder (batch 5), linked (BFS), smart (diff vault vs sessions)</td></tr>
        <tr><td><code>vault_contextualize</code></td><td>Bridge</td><td>7 CLI + 3 Honcho calls in parallel: structural position + semantic perspective + ingestion status</td></tr>
        <tr><td><code>vault_status</code></td><td>Bridge</td><td>Vault file counts + Honcho sessions + coverage % + queue progress</td></tr>
      </tbody>
    </table>
  </div>

  <div class="callout success">
    <strong>Vault tools need no API key.</strong> The 6 pure vault tools work with just <code>OBSIDIAN_VAULT</code>. The 3 bridge tools additionally require <code>HONCHO_API_KEY</code> and lazy-initialize workspace + peers on first use.
  </div>

  <h3>Architecture</h3>
  <div class="mermaid">
%%{init: {'theme': 'dark', 'themeVariables': { 'primaryColor': '#1f3150', 'primaryTextColor': '#c9d1d9', 'primaryBorderColor': '#3d6ea5', 'lineColor': '#3d6ea5', 'secondaryColor': '#162030', 'tertiaryColor': '#11151c', 'edgeLabelBackground': '#0b0e14', 'fontSize': '14px' }, 'flowchart': { 'nodeSpacing': 30, 'rankSpacing': 40 }}}%%
flowchart LR
    A["Agent<br/>(Claude, script)"] -->|MCP| S["MCP Server<br/>9 tools"]
    S -->|"Bun.spawn()"| CLI["Obsidian CLI"]
    S -->|"fetch()"| H["Honcho API"]
    CLI --> V["Vault"]
    V -->|"vault.modify event"| P["Plugin"]
    P -->|"REST"| H

    style A fill:#162030,stroke:#7eb8f6,color:#c9d1d9
    style S fill:#1f3150,stroke:#3d6ea5,color:#c9d1d9
    style CLI fill:#11151c,stroke:#3d6ea5,color:#c9d1d9
    style H fill:#11151c,stroke:#3d6ea5,color:#c9d1d9
    style V fill:#162030,stroke:#7eb8f6,color:#c9d1d9
    style P fill:#1f3150,stroke:#3d6ea5,color:#c9d1d9
  </div>

  <p>The MCP server and the Obsidian plugin are independent. The server uses <code>Bun.spawn()</code> with array args (no shell) for CLI calls and native <code>fetch()</code> for Honcho. The plugin uses Obsidian's internal APIs. When both run simultaneously, they compose: the MCP server writes notes the plugin auto-ingests, and the plugin's pipeline feeds the same Honcho identity the server reads back.</p>

  <h3>Staleness in the MCP server</h3>
  <p>The MCP server doesn't write frontmatter (it can't modify notes without going through the CLI). Instead, it stores <code>content_hash</code> in Honcho session metadata. On re-ingest, it compares the hash of the stripped content against the session's stored hash. Same hash = skip. Different hash = delete session, recreate, re-ingest.</p>

  <h3>Environment</h3>
  <pre><code><span class="key">HONCHO_API_KEY</span>=<span class="str">hc_...</span>        <span class="cm"># Required for bridge tools</span>
<span class="key">HONCHO_BASE_URL</span>=<span class="str">https://api.honcho.dev</span>  <span class="cm"># Default</span>
<span class="key">HONCHO_WORKSPACE</span>=<span class="str">my-vault</span>   <span class="cm"># Default: auto-detected from CLI</span>
<span class="key">HONCHO_OBSERVER</span>=<span class="str">obsidian</span>   <span class="cm"># Default</span>
<span class="key">HONCHO_OBSERVED</span>=<span class="str">obsidian</span>   <span class="cm"># Default: same as observer</span>
<span class="key">OBSIDIAN_VAULT</span>=<span class="str">my-vault</span>    <span class="cm"># Optional: active vault if unset</span></code></pre>

  <h3>Running</h3>
  <pre><code><span class="cm"># Start the server (stdio transport for MCP)</span>
bun run mcp/server.ts

<span class="cm"># Claude Desktop config</span>
{
  "<span class="key">mcpServers</span>": {
    "<span class="str">honcho-vault</span>": {
      "<span class="key">command</span>": "<span class="str">bun</span>",
      "<span class="key">args</span>": ["<span class="str">run</span>", "<span class="str">/path/to/obsidian-honcho/mcp/server.ts</span>"],
      "<span class="key">env</span>": { "<span class="key">HONCHO_API_KEY</span>": "<span class="str">hc_...</span>" }
    }
  }
}</code></pre>

  <h3>Obsidian CLI reference</h3>
  <p>The CLI (<code>obsidian &lt;command&gt;</code>) provides 80+ commands. The MCP server wraps a focused subset; the full CLI is always available for direct use.</p>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Category</th><th>Commands</th></tr></thead>
      <tbody>
        <tr><td>Read / write</td><td><code>read</code>, <code>create</code>, <code>append</code>, <code>prepend</code>, <code>delete</code>, <code>move</code></td></tr>
        <tr><td>Search</td><td><code>search query=&lt;text&gt;</code> with path, limit, format (text/json)</td></tr>
        <tr><td>Structure</td><td><code>links</code>, <code>backlinks</code>, <code>orphans</code>, <code>deadends</code>, <code>unresolved</code>, <code>tags</code>, <code>aliases</code></td></tr>
        <tr><td>Properties</td><td><code>property:read</code>, <code>property:set</code>, <code>property:remove</code>, <code>properties</code></td></tr>
        <tr><td>Daily notes</td><td><code>daily</code>, <code>daily:read</code>, <code>daily:append</code>, <code>daily:prepend</code></td></tr>
        <tr><td>Files</td><td><code>files</code>, <code>folders</code>, <code>file</code> (metadata), <code>outline</code>, <code>wordcount</code></td></tr>
        <tr><td>Plugin control</td><td><code>plugin:enable</code>, <code>plugin:disable</code>, <code>plugin:reload</code>, <code>command id=&lt;id&gt;</code></td></tr>
      </tbody>
    </table>
  </div>

  <h3>Design decisions</h3>
  <ul>
    <li><strong>Why not <code>mcp.honcho.dev</code> for everything?</strong> &mdash; <code>mcp.honcho.dev</code> has 30 Honcho tools but zero vault access. The MCP server fills the vault gap and bridges both.</li>
    <li><strong>Why 9 tools, not 14?</strong> &mdash; The original MCP server (commit <code>7fa0c0e</code>, removed in <code>38828c8</code>) had 14 tools. 5 were pure Honcho tools (<code>vault_memory</code>, <code>vault_dream</code>, <code>vault_chat</code>, <code>vault_sync</code>, <code>vault_analyze</code>) redundant with <code>mcp.honcho.dev</code> or composable by the LLM. Removed.</li>
    <li><strong>Why a separate process?</strong> &mdash; Obsidian plugins can't expose MCP servers. The server runs as a Bun process alongside Obsidian, using the CLI as its vault interface.</li>
    <li><strong>The meta container pattern.</strong> &mdash; Agent ecosystems are converging on plugins as meta containers: install &ldquo;figma&rdquo; and get all the figma tools. This MCP server is how Honcho gets inserted into that system &mdash; it's the meta container that gives every other plugin persistent identity context.</li>
  </ul>
</section>

<!-- =============== PS: API =============== -->
<section id="api-proposals" style="margin-top: 6rem; padding-top: 3rem; border-top: 1px solid var(--border);">
  <h2 style="color: var(--fg-muted); font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.12em; border-bottom: none; padding-bottom: 0; margin-bottom: 0.5rem;">P.S.</h2>
  <h2>API Surface</h2>

  <h3>Currently used</h3>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Capability</th><th>Used by</th></tr></thead>
      <tbody>
        <tr><td><code>getPeerContext</code></td><td>Sidebar (combined card + representation)</td></tr>
        <tr><td><code>search_query</code> on representation</td><td>Contextual representation + chat</td></tr>
        <tr><td><code>setPeerCard</code> (PUT)</td><td>Push note as peer card</td></tr>
        <tr><td><code>peerChatStream</code> (SSE)</td><td>Chat modal</td></tr>
        <tr><td><code>getQueueStatus</code></td><td>Session manager + deferred feedback</td></tr>
        <tr><td><code>scheduleDream</code></td><td>Post-bulk-ingest + manual command</td></tr>
        <tr><td><code>queryConclusions</code></td><td>Search + feedback semantic fallback</td></tr>
        <tr><td><code>listConclusions</code></td><td>Explorer + feedback session-scoped</td></tr>
      </tbody>
    </table>
  </div>

  <h3>Proposals</h3>
  <p>The vault-to-identity pipeline is simulated through conversational primitives. These would make it native.</p>
  <div class="table-wrap">
    <table>
      <thead><tr><th>Proposal</th><th>Why</th></tr></thead>
      <tbody>
        <tr><td>SSE event stream for pipeline events</td><td>Auto-refresh on conclusion arrival and dream completion. Obsidian can't do webhooks</td></tr>
        <tr><td>Temporal filters on conclusions (<code>created_after</code>, <code>session_id</code>)</td><td>"What's new since last sync" without pulling everything</td></tr>
        <tr><td>Bulk ingestion endpoint</td><td>100 notes = ~300 requests. Collapse to 1</td></tr>
        <tr><td>Document Ingestion API</td><td>First-class vault-shaped data &mdash; links, tags as metadata, replace mode native</td></tr>
      </tbody>
    </table>
  </div>
</section>

</div><!-- .container -->

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  mermaid.initialize({
    startOnLoad: true,
    securityLevel: 'loose',
    fontFamily: 'Departure Mono, Noto Emoji, monospace',
    fontSize: 16,
    flowchart: { padding: 20, nodeSpacing: 50, rankSpacing: 60, useMaxWidth: true },
  });
</script>

<script>
  // Theme toggle with localStorage persistence
  (function() {
    const toggle = document.getElementById('theme-toggle');
    const stored = localStorage.getItem('arch-theme');
    if (stored) document.documentElement.setAttribute('data-theme', stored);

    toggle.addEventListener('click', () => {
      const current = document.documentElement.getAttribute('data-theme') || 'dark';
      const next = current === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', next);
      localStorage.setItem('arch-theme', next);
    });
  })();

  window.addEventListener('scroll', () => {
    const bar = document.getElementById('progress');
    const max = document.documentElement.scrollHeight - window.innerHeight;
    bar.style.width = (max > 0 ? (window.scrollY / max) * 100 : 0) + '%';
  });
</script>

</body>
</html>
